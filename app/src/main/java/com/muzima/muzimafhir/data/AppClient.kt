package com.muzima.muzimafhir.data

import GetPersonListQuery
import GetPersonByIdQuery
import com.apollographql.apollo.ApolloCall
import com.apollographql.apollo.ApolloClient
import com.apollographql.apollo.api.Response
import com.apollographql.apollo.exception.ApolloException
import com.google.gson.Gson
import com.muzima.muzimafhir.data.types.Address
import com.muzima.muzimafhir.data.types.HumanName
import okhttp3.OkHttpClient
import java.time.Instant
import java.util.*

class AppClient {


    var gson: Gson = Gson()
    //private var BASE_URL = "http://localhost:3000/4_0_0/\$graphql"
    // Android VM's host address, use either a remote server IP
    // or local IPv4 address for integration testing.
    private var BASE_URL = "http://45.79.198.132:3000/4_0_0/\$graphql" //GraphQL endpoint
    private var apolloClient: ApolloClient

    init {
        apolloClient = getClient()
    }

    /***
     * Builds the Apollo client and assigns it locally
     */
    private fun getClient() : ApolloClient {
        println("Building Apollo client...")
        var okHttpClient = OkHttpClient.Builder().build()
        apolloClient = ApolloClient
            .builder()
            .serverUrl(BASE_URL)
            .okHttpClient(okHttpClient)
            .build()
        println("Apollo client built!")
        return apolloClient
    }

    /***
     * Calls the query GetPersonByIdQuery with the Apollo client.
     * Initialized Apollo client required.
     */
    fun getPerson(id: String, onSuccess: (String, Person) -> Unit ){
        println("Calling getPerson for Person with id $id...")
        println("Building query...")
        // Build the query to be executed from the class generated by Apollo
        var q = GetPersonByIdQuery
                .builder()
                .id(id)
                .build()
        println("Query built!")
        // Define a callback for the client to execute on completion
        // Both onResponse and onFailure are required
        val callBack = object : ApolloCall.Callback<GetPersonByIdQuery.Data>(){
            override fun onResponse(response: Response<GetPersonByIdQuery.Data>) {
                println("Callback onResponse called!")
                var dataPerson = response.data()?.Person()
                //var ret = "The callback returned successfully!"
                println("person as string: " + parsePerson(dataPerson).toString())
                var ret = dataPerson?.name().toString()
                onSuccess(ret, parsePerson(dataPerson))
            }
            override fun onFailure(e: ApolloException) {
                println("Callback onFailure called!")
                println("exception was: ${e.message}")
                println("exception was: ${e.stackTrace}")
                throw e
            }
        }
        // Execute the query with the specified callback
        apolloClient.query(q).enqueue(callBack)
    }

    /***
     * Calls the query GetPersonByIdQuery with the Apollo client.
     * Initialized Apollo client required.
     */
    fun getPersonList(id: String, onSuccess: (String, Person) -> Unit ){
        println("Calling getPerson for Person with id $id...")
        println("Building query...")
        // Build the query to be executed from the class generated by Apollo
        var q = GetPersonListQuery
                .builder()
                .build()
        println("Query built!")
        // Define a callback for the client to execute on completion
        // Both onResponse and onFailure are required
        val callBack = object : ApolloCall.Callback<GetPersonListQuery.Data>(){
            override fun onResponse(response: Response<GetPersonListQuery.Data>) {
                println("Callback onResponse called!")
                var dataPersonList = response.data()?.PersonList()?.entry()
                //var ret = "The callback returned successfully!"
                var l = mutableListOf<Person>()
                dataPersonList?.forEach {
                   
                }
                //println("person as string: " + parsePerson(dataPerson).toString())
                //var ret = dataPerson?.name().toString()
                //onSuccess(ret, parsePerson(dataPerson))
            }
            override fun onFailure(e: ApolloException) {
                println("Callback onFailure called!")
                println("exception was: ${e.message}")
                println("exception was: ${e.stackTrace}")
                throw e
            }
        }
        // Execute the query with the specified callback
        apolloClient.query(q).enqueue(callBack)
    }

    /***
     * Supposed to call query getpatient WIP
     * Initialized Apollo client required.
     */
    fun getPatient(id: String, onSuccess: (String, Patient) -> Unit ){
        println("Calling getPatient for Patient with id $id...")
        println("Building query...")
        // Build the query to be executed from the class generated by Apollo
        var q = GetPatientByIdQuery
                .builder()
                .id(id)
                .build()
        println("Query built!")
        // Define a callback for the client to execute on completion
        // Both onResponse and onFailure are required
        val callBack = object : ApolloCall.Callback<GetPatientByIdQuery.Data>(){
            override fun onResponse(response: Response<GetPatientByIdQuery.Data>) {
                println("Callback onResponse called!")
                var dataPatient = response.data()?.Patient()
                //var ret = "The callback returned successfully!"
                println("Patient as string: " + parsePatient(dataPatient).toString())
                var ret = dataPatient?.name().toString()
                onSuccess(ret, parsePatient(dataPatient))
            }
            override fun onFailure(e: ApolloException) {
                println("Callback onFailure called!")
                println("exception was: ${e.message}")
                println("exception was: ${e.stackTrace}")
                throw e
            }
        }
        // Execute the query with the specified callback
        apolloClient.query(q).enqueue(callBack)
    }



fun parsePerson(person: GetPersonByIdQuery.Person?) : Person {
    var humanNames = mutableListOf<HumanName>()
    var addresses = mutableListOf<Address>()
    person?.name()?.forEach {
        humanNames.add(parseHumanName(it))
    }
    person?.address()?.forEach{
        addresses.add(parseAddress(it))
    }

    var mPerson = Person()
    mPerson.name = humanNames
    mPerson.address = addresses
    mPerson.birthDate = parseDate(person?.birthDate() as String)
    mPerson.gender = person?.gender().toString()
    mPerson.active = person?.active()

    return mPerson
}

fun parseHumanName(name: GetPersonByIdQuery.Name) : HumanName{
    var mHumanName = HumanName()
    mHumanName.family = name.family()
    mHumanName.use = name.use() as String
    mHumanName.text = name.text()
    return mHumanName
}

fun parseDate(date: String) : Date {
    //var d: Date = gson.fromJson(date, Date::class.java)
    var d = Instant.parse(date)
    return Date.from(d)
}

fun parseAddress(address: GetPersonByIdQuery.Address) : Address {
    var mAddress = Address()
    mAddress.line = address.line()
    return mAddress
}



//Patient Parse


    fun parsePatient(patient: GetPatientByIdQuery.Patient?) : Patient {
        var humanNames = mutableListOf<HumanName>()
        var addresses = mutableListOf<Address>()
        patient?.name()?.forEach {
            humanNames.add(parseHumanName(it))
        }
        patient?.address()?.forEach{
            addresses.add(parseAddress(it))
        }

        var mPatient = Patient()
        mPatient.name = humanNames
        mPatient.address = addresses
        mPatient.birthDate = null //parseDate(patient?.birthDate() as String)
        mPatient.gender = patient?.gender().toString()
        mPatient.active = patient?.active()

        return mPatient
    }

    fun parseHumanName(name: GetPatientByIdQuery.Name) : HumanName{
        var mHumanName = HumanName()
        mHumanName.family = name.family()
        return mHumanName
    }

    fun parseAddress(address: GetPatientByIdQuery.Address) : Address {
        var mAddress = Address()
        mAddress.line = address.line()
        return mAddress
    }















}