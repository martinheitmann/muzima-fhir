package com.muzima.muzimafhir.data

import typeFixFolder.*
import com.apollographql.apollo.ApolloCall
import com.apollographql.apollo.ApolloClient
import com.apollographql.apollo.api.Response
import com.apollographql.apollo.exception.ApolloException
import com.google.gson.Gson
import com.muzima.muzimafhir.data.types.Address
import com.muzima.muzimafhir.data.types.HumanName
import okhttp3.OkHttpClient
import typeFixFolder.type.Person_Input
import java.time.Instant
import java.util.*

class AppClient {


    var gson: Gson = Gson()
    //private var BASE_URL = "http://localhost:3000/4_0_0/\$graphql"
    // Android VM's host address, use either a remote server IP
    // or local IPv4 address for integration testing.
    private var BASE_URL = "http://45.79.198.132:3000/4_0_0/\$graphql" //GraphQL endpoint
    private var apolloClient: ApolloClient

    init {
        apolloClient = getClient()
    }

    /***
     * Builds the Apollo client and assigns it locally
     */
    private fun getClient(): ApolloClient {
        println("Building Apollo client...")
        var okHttpClient = OkHttpClient.Builder().build()
        apolloClient = ApolloClient
                .builder()
                .serverUrl(BASE_URL)
                .okHttpClient(okHttpClient)
                .build()
        println("Apollo client built!")
        return apolloClient
    }

    /***
     * Calls the query GetPersonByIdQuery with the Apollo client.
     * Initialized Apollo client required.
     */
    fun getPerson(id: String, onSuccess: (String, Person) -> Unit) {
        println("Calling getPerson for Person with id $id...")
        println("Building query...")
        // Build the query to be executed from the class generated by Apollo
        var q = GetPersonByIdQuery
                .builder()
                .id(id)
                .build()
        println("Query built!")
        // Define a callback for the client to execute on completion
        // Both onResponse and onFailure are required
        val callBack = object : ApolloCall.Callback<GetPersonByIdQuery.Data>() {
            override fun onResponse(response: Response<GetPersonByIdQuery.Data>) {
                println("Callback onResponse called!")
                var dataPerson = response.data()?.Person()
                //var ret = "The callback returned successfully!"
                println("person as string: " + parsePerson(dataPerson).toString())
                var ret = dataPerson?.name().toString()
                onSuccess(ret, parsePerson(dataPerson))
            }

            override fun onFailure(e: ApolloException) {
                println("Callback onFailure called!")
                println("exception was: ${e.message}")
                println("exception was: ${e.stackTrace}")
                throw e
            }
        }
        // Execute the query with the specified callback
        apolloClient.query(q).enqueue(callBack)
    }

    /***
     * Calls the query GetPersonByIdQuery with the Apollo client.
     * Initialized Apollo client required.
     */
    fun getPersonList(id: String, onSuccess: (String, Person) -> Unit) {
        println("Calling getPerson for Person with id $id...")
        println("Building query...")
        // Build the query to be executed from the class generated by Apollo
        var q = GetPersonListQuery
                .builder()
                .build()
        println("Query built!")
        // Define a callback for the client to execute on completion
        // Both onResponse and onFailure are required
        val callBack = object : ApolloCall.Callback<GetPersonListQuery.Data>() {
            override fun onResponse(response: Response<GetPersonListQuery.Data>) {
                println("Callback onResponse called!")
                var dataPersonList = response.data()?.PersonList()?.entry()
                //var ret = "The callback returned successfully!"
                var l = mutableListOf<Person>()
                dataPersonList?.forEach {

                }
                //println("person as string: " + parsePerson(dataPerson).toString())
                //var ret = dataPerson?.name().toString()
                //onSuccess(ret, parsePerson(dataPerson))
            }

            override fun onFailure(e: ApolloException) {
                println("Callback onFailure called!")
                println("exception was: ${e.message}")
                println("exception was: ${e.stackTrace}")
                throw e
            }
        }
        // Execute the query with the specified callback
        apolloClient.query(q).enqueue(callBack)
    }

    /**
     * PersonCreateMutation
     * Create Person and send resource to server
     */
    fun createPerson(person: Person_Input, onSuccess: (String, Person) -> Unit) {
        println("Building query...")
        // Build the query to be executed from the class generated by Apollo
        var m = PersonCreateMutation
                .builder()
                .person(person)
                .build()
        println("Query built!")
        // Define a callback for the client to execute on completion
        // Both onResponse and onFailure are required
        val callBack = object : ApolloCall.Callback<PersonCreateMutation.Data>() {
            override fun onResponse(response: Response<PersonCreateMutation.Data>) {
                println("Callback onResponse called!")
                var dataPerson = response.data()?.PersonCreate()
                //var ret = "The callback returned successfully!"
                println("PersonCreateMutationResponse: " + dataPerson.toString())
                //println("person as string: " + parsePerson(dataPerson).toString())
                // var ret = dataPerson?.name().toString()
                //onSuccess(ret, parsePerson(dataPerson))
            }

            override fun onFailure(e: ApolloException) {
                println("Callback onFailure called!")
                println("exception was: ${e.message}")
                println("exception was: ${e.stackTrace}")
                throw e
            }
        }
        // Execute the query with the specified callback
        apolloClient.mutate(m).enqueue(callBack)
    }

    /***
     * Gets a Patient from the server set at the beginning of this doc
     * with the ID specified in the PatientActivity class
     * Initialized Apollo client required.
     */
    fun getPatient(id: String, onSuccess: (String, Patient) -> Unit) {
        println("Calling getPatient for Patient with id $id...")
        println("Building query...")
        // Build the query to be executed from the class generated by Apollo
        var q = GetPatientByIdQuery
                .builder()
                .id(id)
                .build()
        println("Query built!")
        // Define a callback for the client to execute on completion
        // Both onResponse and onFailure are required
        val callBack = object : ApolloCall.Callback<GetPatientByIdQuery.Data>() {
            override fun onResponse(response: Response<GetPatientByIdQuery.Data>) {
                println("Callback onResponse called!")
                var dataPatient = response.data()?.Patient()
                //var ret = "The callback returned successfully!"
                println("Patient as string: " + parsePatient(dataPatient).toString())
                var ret = dataPatient?.name().toString()
                onSuccess(ret, parsePatient(dataPatient))
            }

            override fun onFailure(e: ApolloException) {
                println("Callback onFailure called!")
                println("exception was: ${e.message}")
                println("exception was: ${e.stackTrace}")
                throw e
            }
        }
        // Execute the query with the specified callback
        apolloClient.query(q).enqueue(callBack)
    }
    /***
     * Gets a Encounter from the server set at the beginning of this doc
     * with the ID specified in the EncounterActivity class
     * Initialized Apollo client required.
     */
    fun getEncounter(id: String, onSuccess: (String, Encounter) -> Unit) {
        println("Calling getEncounter for Encounter with id $id...")
        println("Building query...")
        // Build the query to be executed from the class generated by Apollo
        var q = typeFixFolder.GetEncounterByIdQuery
                .builder()
                .id(id)
                .build()
        println("Query built!")
        // Define a callback for the client to execute on completion
        // Both onResponse and onFailure are required
        val callBack = object : ApolloCall.Callback<GetEncounterByIdQuery.Data>() {
            override fun onResponse(response: Response<GetEncounterByIdQuery.Data>) {
                println("Callback onResponse called!")
                var dataEncounter = response.data()?.Encounter()
                //var ret = "The callback returned successfully!"
                println("Encounter as string: " + parseEncounter(dataEncounter).toString())
                var ret = dataEncounter?.id().toString()
                onSuccess(ret, parseEncounter(dataEncounter))
            }

            override fun onFailure(e: ApolloException) {
                println("Callback onFailure called!")
                println("exception was: ${e.message}")
                println("exception was: ${e.stackTrace}")
                throw e
            }
        }
        // Execute the query with the specified callback
        apolloClient.query(q).enqueue(callBack)
    }

    fun parsePerson(person: GetPersonByIdQuery.Person?): Person {
        var humanNames = mutableListOf<HumanName>()
        var addresses = mutableListOf<Address>()
        person?.name()?.forEach {
            humanNames.add(parseHumanName(it))
        }
        person?.address()?.forEach {
            addresses.add(parseAddress(it))
        }

        var mPerson = Person()
        mPerson.name = humanNames
        mPerson.address = addresses
        mPerson.birthDate = parseDate(person?.birthDate() as String)
        mPerson.gender = person?.gender().toString()
        mPerson.active = person?.active()

        return mPerson
    }

    fun parseHumanName(name: GetPersonByIdQuery.Name): HumanName {
        var mHumanName = HumanName()
        mHumanName.family = name.family()
        mHumanName.use = name.use() as String
        mHumanName.text = name.text()
        return mHumanName
    }

    fun parseDate(date: String): Date {
        //var d: Date = gson.fromJson(date, Date::class.java)
        var d = Instant.parse(date)
        return Date.from(d)
    }

    fun parseAddress(address: GetPersonByIdQuery.Address): Address {
        var mAddress = Address()
        mAddress.line = address.line()
        return mAddress
    }


    //Patient Parse

    fun parsePatient(patient: GetPatientByIdQuery.Patient?): Patient {
        var humanNames = mutableListOf<HumanName>()
        var addresses = mutableListOf<Address>()
        patient?.name()?.forEach {
            humanNames.add(parseHumanName(it))
        }
        patient?.address()?.forEach {
            addresses.add(parseAddress(it))
        }

        var mPatient = Patient()
        mPatient.name = humanNames
        mPatient.address = addresses
        mPatient.birthDate = null //parseDate(patient?.birthDate() as String)
        mPatient.gender = patient?.gender().toString()
        mPatient.active = patient?.active()

        return mPatient
    }

    fun parseHumanName(name: GetPatientByIdQuery.Name): HumanName {
        var mHumanName = HumanName()
        mHumanName.family = name.family()
        return mHumanName
    }

    fun parseAddress(address: GetPatientByIdQuery.Address): Address {
        var mAddress = Address()
        mAddress.line = address.line()
        return mAddress
    }

    fun parseEncounter(encounter: GetEncounterByIdQuery.Encounter?): Encounter{
        var mEncounter = Encounter()
        mEncounter.status = encounter?.status().toString()
        return mEncounter;
    }

}